
library(lme4)
library(lmerTest)



# In order to use a vector of proportions as the response variable with glmer
# (., family = binomial), you need to set the number of trials that led to each proportion 
# using the weights argument. For example, using the cbpp data from the lme4 package:

data(cbpp)  # this data is from lme4


m1 <- glmer(incidence / size ~ period + (1 | herd), weights = size,
      family = binomial, data = cbpp)

summary(m1)

## glmmFAQ
## http://bbolker.github.io/mixedmodels-misc/glmmFAQ.html





# application to your data?
mX <- glmer(performance / count ~ whatever + (1 | random), weights = count,
            family = binomial, data = data)







# For categorical variable x continuous/categorical interactions



# Contrast matrix
library(multcomp)

??glht

# Example from my own analysis
### Text difficult, modes of reading for Non-dyslexic readers

contrast.matrixA = rbind(
  #  "MRTD" = c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  #  0,0))# intercept only, non-dyslexics, difficult text, reading
  "Non-dyslexics, Text: Difficult, Mode L - Mode R" = 
    c(1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
      0,0) - c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
               0,0),
  "Non-dyslexics, Text: Difficult, Mode RAS - Mode R" = 
    c(1, 0, 1, 0, 0, 0, 0, 0, 0, 0,
      0,0) - c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
               0,0),
  "Non-dyslexics, Text: Difficult, Mode RAS - Mode L" = 
    c(1, 0, 1, 0, 0, 0, 0, 0, 0, 0,
      0,0) - c(1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
               0,0)) 

comps <- glht(glmer17a, contrast.matrixA)
summary(comps)



#### Correlations
#Correlation table between selected predictors

panel.cor <- function(x, y, digits=2, prefix="", cex.cor)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r = (cor(x, y))
  txt <- format(c(r, 0.123456789), digits=digits)[1]
  txt <- paste(prefix, txt, sep="")
  if(missing(cex.cor)) cex <- 0.8/strwidth(txt)
  text(0.5, 0.5, txt, cex = cex * abs(r))
}


# pretty correlation table:
# -- with stars to show significance
# just a correlation table, taken from here:
#   http://myowelt.blogspot.com/2008/04/beautiful-correlation-tables-in-r.html
# actually adapted from prvious nabble thread:

corstarsl <- function(x){ 
  require(Hmisc) 
  x <- as.matrix(x) 
  R <- rcorr(x)$r 
  p <- rcorr(x)$P 
  
  ## define notions for significance levels; spacing is important.
  mystars <- ifelse(p < .001, "***", ifelse(p < .01, "** ", ifelse(p < .05, "* ", " ")))
  
  ## trunctuate the matrix that holds the correlations to two decimal
  R <- format(round(cbind(rep(-1.11, ncol(x)), R), 2))[,-1] 
  
  ## build a new matrix that includes the correlations with their apropriate stars 
  Rnew <- matrix(paste(R, mystars, sep=""), ncol=ncol(x)) 
  diag(Rnew) <- paste(diag(R), " ", sep="") 
  rownames(Rnew) <- colnames(x) 
  colnames(Rnew) <- paste(colnames(x), "", sep="") 
  
  ## remove upper triangle
  Rnew <- as.matrix(Rnew)
  Rnew[upper.tri(Rnew, diag = TRUE)] <- ""
  Rnew <- as.data.frame(Rnew) 
  
  ## remove last column and return the matrix (which is now a data frame)
  Rnew <- cbind(Rnew[1:length(Rnew)-1])
  return(Rnew) 
}

corstarsl(dataframe with continuous predictors)




## Multicollinearity diagnostics 

# Conventionally, multicollinearity is diagnosed where any pair of predictor vari-
# ables correlates r > :8. But it may obtain even where that is not the case { as
# discussed by Baayen (2008; Belsey et al., 1980) { the recommendation is then to
# use the condition number diagnostic.

library(languageR)
# collinearity diagnostic - Baayen's languageR library
collin.fnc(na.omit(dataframe with continuous predictors))$cnumber

# -- if the number returned is over 15-30 we might worry
# -- what can we do to fix the problem, if any?
# -- there are a number of potential solutions: selecting predictors; combining predictors; using dimension reduction
# techniques like Principal Components Analysis



